{"version":3,"sources":["webpack:///./~/baobab-react/higher-order.js?c34f","webpack:///./~/baobab-react/dist-modules/higher-order.js?1051","webpack:///./~/baobab-react/dist-modules/utils/type.js?320f","webpack:///./~/baobab/index.js?1ba8","webpack:///./~/baobab/src/baobab.js?bb7f","webpack:///./~/baobab/src/cursor.js?a063","webpack:///./~/baobab/~/emmett/emmett.js?288b","webpack:///./~/baobab/src/helpers.js?8481","webpack:///./~/baobab/src/type.js?2980","webpack:///./~/baobab/src/facet.js?dafe","webpack:///./~/baobab/defaults.js?b83c","webpack:///./~/baobab/src/update.js?8cfd","webpack:///./~/baobab/src/merge.js?ea88","webpack:///./~/baobab-react/dist-modules/utils/prop-types.js?c6a8","webpack:///./src/pages/Login/login.jsx","webpack:///./~/classnames/index.js","webpack:///./src/pages/Login/components/SignInForm.jsx"],"names":[],"mappings":";;;;;AAAA;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;AAED,oDAAmD,gBAAgB,sBAAsB,OAAO,2BAA2B,0BAA0B,yDAAyD,2BAA2B,EAAE,EAAE,EAAE,eAAe;;AAE9P,kCAAiC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE,EAAE,yDAAyD,qEAAqE,6DAA6D,oBAAoB,GAAG,EAAE;;AAEljB,yCAAwC,mBAAmB,4BAA4B,kDAAkD,oCAAoC,gBAAgB,kDAAkD,8DAA8D,0BAA0B,4CAA4C,uBAAuB,kBAAkB,EAAE,OAAO,cAAc,gBAAgB,gBAAgB,eAAe,oBAAoB,EAAE,EAAE,4BAA4B,mBAAmB,EAAE,OAAO,uBAAuB,4BAA4B,kBAAkB,EAAE,8BAA8B,EAAE,EAAE;;AAE3pB;AACA;;AAEA,uCAAsC,uCAAuC,kBAAkB;;AAE/F,kDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,2CAA0C,+DAA+D,qGAAqG,EAAE,yEAAyE,eAAe,yEAAyE,EAAE,EAAE,iDAAiD;;AAEta;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uEAAsE;;AAEtE;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAS;;AAET;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA,uEAAsE;AACtE;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA,IAAG;;AAEH;AACA,E;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uB;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAuB,2BAA2B;AAClD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA4B,aAAa;;AAEzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AC/PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,4BAA2B,2BAA2B;;AAEtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AC7bA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB;AACA;AACA,eAAc;AACd;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAc,MAAM;AACpB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,SAAS;AACvB,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,sCAAqC,OAAO;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,QAAQ;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS,SAAS;AAClB;AACA,UAAS,QAAQ;AACjB;AACA;AACA;AACA;AACA,6CAA4C,gBAAgB,EAAE;AAC9D;AACA,6CAA4C,gBAAgB,EAAE,GAAG,aAAa;AAC9E;AACA,eAAc,OAAO;AACrB,eAAc,SAAS;AACvB,eAAc,QAAQ;AACtB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,uBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA,uBAAsB,gBAAgB;AACtC,WAAU;AACV;AACA;AACA,eAAc,MAAM;AACpB,eAAc,SAAS;AACvB,eAAc,QAAQ;AACtB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,iCAAgC,gBAAgB,EAAE;AAClD,iCAAgC,gBAAgB;AAChD,SAAQ;AACR;AACA;AACA,iCAAgC,gBAAgB,EAAE;AAClD,iCAAgC,gBAAgB;AAChD,SAAQ,GAAG,aAAa;AACxB;AACA,eAAc,OAAO;AACrB,eAAc,QAAQ;AACtB,eAAc,QAAQ;AACtB;AACA;AACA;AACA,kCAAiC,gBAAgB,EAAE;AACnD;AACA,kCAAiC,gBAAgB,EAAE,GAAG,YAAY;AAClE;AACA,eAAc,SAAS;AACvB,eAAc,QAAQ;AACtB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mCAAkC,OAAO;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAuB;AACvB;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAAyC,WAAW;AACpD;AACA,kBAAiB,WAAW;;AAE5B;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,SAAS;AACvB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,eAAc,MAAM;AACpB,eAAc,SAAS;AACvB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA,eAAc,OAAO;AACrB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,eAAc,SAAS;AACvB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,QAAQ;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAkC,OAAO;AACzC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qCAAoC,OAAO;AAC3C;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAc,QAAQ;AACtB,eAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,kDAAiD,OAAO;AACxD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,qCAAqC;AAC5D;AACA,eAAc,aAAa;AAC3B,eAAc,QAAQ;AACtB,eAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAkC,OAAO;AACzC;;AAEA,uCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,eAAc,QAAQ;AACtB;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,eAAc,QAAQ;AACtB;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,MAAK;AACL;AACA;AACA,EAAC;;;;;;;;ACxiBD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,8BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+BAA8B,OAAO;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA8B,OAAO;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAA+B,OAAO;AACtC;;AAEA;AACA;;AAEA;AACA,gCAA+B,OAAO;AACtC;;AAEA;AACA;;AAEA;AACA,gCAA+B,OAAO;AACtC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;;AAEA,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC3ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;;;;;;;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClLA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,aAAY;;AAEZ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,WAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAmC,OAAO;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;;;;;;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAsC;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mDAAkD;AAClD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mDAAkD;AAClD;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA,4B;;;;;;;;;;;;;;;;;;;;;;;uCCxCuB,GAAY;;;;mDACd,GAA2B;;wCACR,GAAc;;iDAE/B,GAAyB;;;;KAG1C,KAAK;aAAL,KAAK;;AACE,YADP,KAAK,GACY;2BADjB,KAAK;;uCACM,IAAI;AAAJ,WAAI;;;AACjB,gCAFE,KAAK,8CAEE,IAAI,EAAE;AACf,SAAI,CAAC,KAAK,GAAG,EAAE,CAAC;IACjB;;gBAJG,KAAK;;YAMU,6BAAC,SAAS,EAAE,SAAS,EAAE;AACxC,WAAI,CAAC,SAAS,IAAI,CAAC,SAAS,CAAC,cAAc,EAAE;AAC3C,gBAAO;QACR;AACD,WAAM,WAAW,GAAG,SAAS,CAAC,cAAc,CAAC,WAAW,CAAC;AACzD,WAAI,WAAW,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,uBAAuB,CAAC,EAAE;AACvE,aAAM,OAAM,GAAG,CAAC,CAAC,GAAG,CAAC,SAAS,EAAE,iCAAiC,CAAC,CAAC;AACnE,aAAI,CAAC,OAAO,CAAC,MAAM,CAAC,YAAY,CAAC,OAAM,CAAC,CAAC;QAC1C;MACF;;;YAEK,kBAAG;AACP,WAAI,OAAO,GAAG,6BAAW;AACvB,yBAAgB,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI;QAClC,CAAC,CAAC;;AAEH,cACE;AAAC,aAAI;;SACH;AAAC,cAAG;;WACF;AAAC,gBAAG;eAAC,EAAE,EAAE,CAAE;aACT;AAAC,6BAAc;;eACb;AAAC,sBAAK;;iBAEJ,4DAAc;gBAER;cACO;YACb;UACF;QACD,CACP;MACH;;;UArCG,KAAK;IAAS,KAAK,CAAC,SAAS;;AAwCnC,MAAK,CAAC,YAAY,GAAG;AACnB,SAAM,EAAE,KAAK,CAAC,SAAS,CAAC,MAAM;EAC/B,CAAC;;sBAEa,oCAAO,KAAK,EAAE;AAC3B,UAAO,EAAE;AACP,mBAAc,EAAE,gBAAgB;AAChC,2BAAsB,EAAE,wBAAwB;IACjD;EACF,CAAC;;;;;;;;ACxDF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAgB;;AAEhB;AACA;;AAEA,kBAAiB,sBAAsB;AACvC;AACA;;AAEA;;AAEA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA,IAAG;AACH,GAAE;AACF;AACA;AACA,EAAC;;;;;;;;;;;;;;;;;;;;;;wCC/CqC,GAAc;;yDAC/B,yJAA+B;;KAE9C,UAAU;aAAV,UAAU;;YAAV,UAAU;2BAAV,UAAU;;gCAAV,UAAU;;;gBAAV,UAAU;;YAEE,oBAAC,CAAC;;;;AAChB,cAAC,CAAC,cAAc,EAAE,CAAC;;6CACb,0CAAO,CAAC,CAAC;;;;;;;MAChB;;;YAEK,kBAAG;AACP,cACE;;WAAK,KAAK,EAAE,EAAC,OAAO,EAAE,EAAE,EAAE,UAAU,EAAE,CAAC,EAAE,aAAa,EAAE,CAAC,EAAE,MAAM,EAAE,MAAM,EAAE,YAAY,EAAE,EAAE,EAAE,SAAS,EAAE,EAAE,EAAE;SAC1G;AAAC,eAAI;aAAC,QAAQ,EAAE,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAE;WACzC;AAAC,sBAAS;;aACR;AAAC,yBAAU;iBAAC,EAAE;eACZ;AAAC,gCAAe;;iBACd,oBAAC,IAAI,IAAC,KAAK,EAAC,oBAAoB,GAAG;gBACnB;eAClB,oBAAC,KAAK,IAAC,SAAS,QAAC,IAAI,EAAC,OAAO,EAAC,EAAE,EAAC,cAAc,EAAC,SAAS,EAAC,mBAAmB,EAAC,WAAW,EAAC,wBAAwB,GAAG;cAC1G;YACH;WACZ;AAAC,sBAAS;;aACR;AAAC,yBAAU;iBAAC,EAAE;eACZ;AAAC,gCAAe;;iBACd,oBAAC,IAAI,IAAC,KAAK,EAAC,mBAAmB,GAAG;gBAClB;eAClB,oBAAC,KAAK,IAAC,IAAI,EAAC,UAAU,EAAC,EAAE,EAAC,UAAU,EAAC,SAAS,EAAC,mBAAmB,EAAC,WAAW,EAAC,UAAU,GAAG;cACjF;YACH;WACZ;AAAC,sBAAS;;aACR;AAAC,mBAAI;;eACH;AAAC,oBAAG;;iBACF;AAAC,sBAAG;qBAAC,EAAE,EAAE,CAAE,EAAC,YAAY,QAAC,aAAa,QAAC,KAAK,EAAE,EAAC,UAAU,EAAE,EAAE,EAAE;mBAC7D;;uBAAM,EAAE,EAAC,aAAa;;oBAA8B;kBAChD;iBACN;AAAC,sBAAG;qBAAC,EAAE,EAAE,CAAE,EAAC,YAAY,QAAC,aAAa,QAAC,SAAS,EAAC,YAAY;mBAC3D;AAAC,2BAAM;uBAAC,QAAQ,QAAC,EAAE,QAAC,IAAI,EAAC,QAAQ,EAAC,OAAO,EAAC,MAAM,EAAC,OAAO,EAAE,IAAI,CAAC,IAAK;;oBAAe;kBAC/E;gBACF;cACD;YACG;UACP;QACH,CACN;MACH;;;UA1CG,UAAU;IAAS,KAAK,CAAC,SAAS;;sBA6CzB,UAAU","file":"3.app.js","sourcesContent":["module.exports = require('./dist-modules/higher-order.js');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab-react/higher-order.js\n ** module id = 232\n ** module chunks = 1 3\n **/","/**\n * Baobab-React Higher Order Component\n * ====================================\n *\n * ES6 higher order component to enchance one's component.\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nexports.root = root;\nexports.branch = branch;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; }\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _utilsTypeJs = require('./utils/type.js');\n\nvar _utilsTypeJs2 = _interopRequireDefault(_utilsTypeJs);\n\nvar _utilsPropTypesJs = require('./utils/prop-types.js');\n\nvar _utilsPropTypesJs2 = _interopRequireDefault(_utilsPropTypesJs);\n\n/**\n * Root component\n */\n\nfunction root(Component, tree) {\n  if (!_utilsTypeJs2['default'].Baobab(tree)) throw Error('baobab-react:higher-order.root: given tree is not a Baobab.');\n\n  var ComposedComponent = (function (_React$Component) {\n    _inherits(ComposedComponent, _React$Component);\n\n    function ComposedComponent() {\n      _classCallCheck(this, ComposedComponent);\n\n      _get(Object.getPrototypeOf(ComposedComponent.prototype), 'constructor', this).apply(this, arguments);\n    }\n\n    _createClass(ComposedComponent, [{\n      key: 'getChildContext',\n\n      // Handling child context\n      value: function getChildContext() {\n        return {\n          tree: tree\n        };\n      }\n    }, {\n      key: 'render',\n\n      // Render shim\n      value: function render() {\n        return _react2['default'].createElement(Component, this.props);\n      }\n    }], [{\n      key: 'childContextTypes',\n      value: {\n        tree: _utilsPropTypesJs2['default'].baobab\n      },\n      enumerable: true\n    }]);\n\n    return ComposedComponent;\n  })(_react2['default'].Component);\n\n  return ComposedComponent;\n}\n\n/**\n * Branch component\n */\n\nfunction branch(Component) {\n  var specs = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n  if (!_utilsTypeJs2['default'].Object(specs)) throw Error('baobab-react.higher-order: invalid specifications ' + '(should be an object with cursors and/or facets key).');\n\n  var ComposedComponent = (function (_React$Component2) {\n    _inherits(ComposedComponent, _React$Component2);\n\n    _createClass(ComposedComponent, [{\n      key: 'getChildContext',\n\n      // Child context\n      value: function getChildContext() {\n        return {\n          cursors: this.facet.cursors,\n          facets: this.facet.facets\n        };\n      }\n    }], [{\n      key: 'contextTypes',\n      value: {\n        tree: _utilsPropTypesJs2['default'].baobab\n      },\n      enumerable: true\n    }, {\n      key: 'childContextTypes',\n      value: {\n        cursors: _utilsPropTypesJs2['default'].cursors,\n        facets: _utilsPropTypesJs2['default'].facets\n      },\n      enumerable: true\n    }]);\n\n    // Building initial state\n\n    function ComposedComponent(props, context) {\n      _classCallCheck(this, ComposedComponent);\n\n      _get(Object.getPrototypeOf(ComposedComponent.prototype), 'constructor', this).call(this, props, context);\n\n      var facet = context.tree.createFacet(specs, [props, context]);\n\n      if (facet) this.state = facet.get();\n\n      this.facet = facet;\n    }\n\n    _createClass(ComposedComponent, [{\n      key: 'componentWillMount',\n\n      // On component mount\n      value: function componentWillMount() {\n        if (!this.facet) return;\n\n        var handler = (function () {\n          this.setState(this.facet.get());\n        }).bind(this);\n\n        this.facet.on('update', handler);\n      }\n    }, {\n      key: 'render',\n\n      // Render shim\n      value: function render() {\n        return _react2['default'].createElement(Component, _extends({}, this.props, this.state));\n      }\n    }, {\n      key: 'componentWillUnmount',\n\n      // On component unmount\n      value: function componentWillUnmount() {\n        if (!this.facet) return;\n\n        // Releasing facet\n        this.facet.release();\n        this.facet = null;\n      }\n    }, {\n      key: 'componentWillReceiveProps',\n\n      // On new props\n      value: function componentWillReceiveProps(props) {\n        if (!this.facet) return;\n\n        this.facet.refresh([props, this.context]);\n        this.setState(this.facet.get());\n      }\n    }]);\n\n    return ComposedComponent;\n  })(_react2['default'].Component);\n\n  return ComposedComponent;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab-react/dist-modules/higher-order.js\n ** module id = 233\n ** module chunks = 1 3\n **/","/**\n * Baobab-React Type Checking\n * ===========================\n *\n * Some helpers to perform runtime validations.\n */\n'use strict';\n\nvar Baobab = require('baobab'),\n    Cursor = Baobab.Cursor,\n    Facet = Baobab.Facet;\n\nvar type = {};\n\ntype.Object = function (value) {\n  return value && typeof value === 'object' && !Array.isArray(value) && !(value instanceof Date) && !(value instanceof RegExp);\n};\n\ntype.Baobab = function (value) {\n  return value instanceof Baobab;\n};\n\ntype.Cursor = function (value) {\n  return value instanceof Cursor;\n};\n\ntype.Facet = function (value) {\n  return value instanceof Facet;\n};\n\nmodule.exports = type;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab-react/dist-modules/utils/type.js\n ** module id = 234\n ** module chunks = 1 3\n **/","/**\n * Baobab Public Interface\n * ========================\n *\n * Exposes the main library classes.\n */\nvar Baobab = require('./src/baobab.js'),\n    Cursor = require('./src/cursor.js'),\n    Facet = require('./src/facet.js'),\n    helpers = require('./src/helpers.js');\n\n// Non-writable version\nObject.defineProperty(Baobab, 'version', {\n  value: '1.1.2'\n});\n\n// Exposing Cursor and Facet classes\nBaobab.Cursor = Cursor;\nBaobab.Facet = Facet;\n\n// Exposing helpers\nBaobab.getIn = helpers.getIn;\n\n// Exporting\nmodule.exports = Baobab;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/index.js\n ** module id = 235\n ** module chunks = 1 3\n **/","/**\n * Baobab Data Structure\n * ======================\n *\n * A handy data tree with cursors.\n */\nvar Cursor = require('./cursor.js'),\n    EventEmitter = require('emmett'),\n    Facet = require('./facet.js'),\n    helpers = require('./helpers.js'),\n    update = require('./update.js'),\n    merge = require('./merge.js'),\n    defaults = require('../defaults.js'),\n    type = require('./type.js');\n\nvar uniqid = (function() {\n  var i = 0;\n  return function() {\n    return i++;\n  };\n})();\n\n/**\n * Main Class\n */\nfunction Baobab(initialData, opts) {\n  if (arguments.length < 1)\n    initialData = {};\n\n  // New keyword optional\n  if (!(this instanceof Baobab))\n    return new Baobab(initialData, opts);\n\n  if (!type.Object(initialData) && !type.Array(initialData))\n    throw Error('Baobab: invalid data.');\n\n  // Extending\n  EventEmitter.call(this);\n\n  // Merging defaults\n  this.options = helpers.shallowMerge(defaults, opts);\n\n  // Privates\n  this._transaction = {};\n  this._future = undefined;\n  this._cursors = {};\n  this._identity = '[object Baobab]';\n\n  // Properties\n  this.log = [];\n  this.previousData = null;\n  this.data = initialData;\n  this.root = this.select();\n  this.facets = {};\n\n  // Immutable tree?\n  if (this.options.immutable)\n    helpers.deepFreeze(this.data);\n\n  // Boostrapping root cursor's methods\n  function bootstrap(name) {\n    this[name] = function() {\n      var r = this.root[name].apply(this.root, arguments);\n      return r instanceof Cursor ? this : r;\n    };\n  }\n\n  [\n    'apply',\n    'chain',\n    'get',\n    'merge',\n    'push',\n    'set',\n    'splice',\n    'unset',\n    'unshift',\n    'update'\n  ].forEach(bootstrap.bind(this));\n\n  // Facets\n  if (!type.Object(this.options.facets))\n    throw Error('Baobab: invalid facets.');\n\n  for (var k in this.options.facets)\n    this.addFacet(k, this.options.facets[k]);\n}\n\nhelpers.inherits(Baobab, EventEmitter);\n\n/**\n * Prototype\n */\nBaobab.prototype.addFacet = function(name, definition, args) {\n  this.facets[name] = this.createFacet(definition, args);\n  return this;\n};\n\nBaobab.prototype.createFacet = function(definition, args) {\n  return new Facet(this, definition, args);\n};\n\nBaobab.prototype.select = function(path) {\n  path = path || [];\n\n  if (arguments.length > 1)\n    path = helpers.arrayOf(arguments);\n\n  if (!type.Path(path))\n    throw Error('Baobab.select: invalid path.');\n\n  // Casting to array\n  path = [].concat(path);\n\n  // Computing hash\n  var hash = path.map(function(step) {\n    if (type.Function(step) || type.Object(step))\n      return '$' + uniqid() + '$';\n    else\n      return step;\n  }).join('|Î»|');\n\n  // Registering a new cursor or giving the already existing one for path\n  var cursor;\n  if (!this._cursors[hash]) {\n    cursor = new Cursor(this, path, hash);\n    this._cursors[hash] = cursor;\n  }\n  else {\n    cursor = this._cursors[hash];\n  }\n\n  // Emitting an event\n  this.emit('select', {path: path, cursor: cursor});\n  return cursor;\n};\n\n// TODO: if syncwrite wins: drop skipMerge, this._transaction etc.\n// TODO: uniq'ing the log through path hashing\nBaobab.prototype.stack = function(spec, skipMerge) {\n  var self = this;\n\n  if (!type.Object(spec))\n    throw Error('Baobab.update: wrong specification.');\n\n  if (!this.previousData)\n    this.previousData = this.data;\n\n  // Applying modifications\n  if (this.options.syncwrite) {\n    var result = update(this.data, spec, this.options);\n    this.data = result.data;\n    this.log = [].concat(this.log).concat(result.log);\n  }\n  else {\n    this._transaction = (skipMerge && !Object.keys(this._transaction).length) ?\n      spec :\n      merge(this._transaction, spec);\n  }\n\n  // Should we let the user commit?\n  if (!this.options.autoCommit)\n    return this;\n\n  // Should we update synchronously?\n  if (!this.options.asynchronous)\n    return this.commit();\n\n  // Updating asynchronously\n  if (!this._future)\n    this._future = setTimeout(self.commit.bind(self, null), 0);\n\n  return this;\n};\n\nBaobab.prototype.commit = function() {\n\n  if (this._future)\n    this._future = clearTimeout(this._future);\n\n  if (!this.options.syncwrite) {\n\n    // Applying the asynchronous transaction\n    var result = update(this.data, this._transaction, this.options);\n    this.data = result.data;\n    this.log = result.log;\n  }\n\n  // Resetting transaction\n  this._transaction = {};\n\n  // Validate?\n  var validate = this.options.validate,\n      behavior = this.options.validationBehavior;\n\n  if (typeof validate === 'function') {\n    var error = validate.call(this, this.previousData, this.data, this.log);\n\n    if (error instanceof Error) {\n      this.emit('invalid', {error: error});\n\n      if (behavior === 'rollback') {\n        this.data = this.previousData;\n        return this;\n      }\n    }\n  }\n\n  // Baobab-level update event\n  this.emit('update', {\n    log: this.log,\n    previousData: this.previousData,\n    data: this.data\n  });\n\n  this.log = [];\n  this.previousData = null;\n\n  return this;\n};\n\nBaobab.prototype.release = function() {\n  var k;\n\n  delete this.data;\n  delete this._transaction;\n\n  // Releasing cursors\n  for (k in this._cursors)\n    this._cursors[k].release();\n  delete this._cursors;\n\n  // Releasing facets\n  for (k in this.facets)\n    this.facets[k].release();\n  delete this.facets;\n\n  // Killing event emitter\n  this.kill();\n};\n\n/**\n * Output\n */\nBaobab.prototype.toJSON = function() {\n  return this.get();\n};\n\nBaobab.prototype.toString = function() {\n  return this._identity;\n};\n\n/**\n * Export\n */\nmodule.exports = Baobab;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/src/baobab.js\n ** module id = 236\n ** module chunks = 1 3\n **/","/**\n * Baobab Cursor Abstraction\n * ==========================\n *\n * Nested selection into a baobab tree.\n */\nvar EventEmitter = require('emmett'),\n    helpers = require('./helpers.js'),\n    defaults = require('../defaults.js'),\n    type = require('./type.js');\n\n/**\n * Main Class\n */\nfunction Cursor(tree, path, hash) {\n  var self = this;\n\n  // Extending event emitter\n  EventEmitter.call(this);\n\n  // Enforcing array\n  path = path || [];\n\n  // Privates\n  this._identity = '[object Cursor]';\n  this._additionnalPaths = [];\n\n  // Properties\n  this.tree = tree;\n  this.path = path;\n  this.hash = hash;\n  this.archive = null;\n  this.recording = false;\n  this.undoing = false;\n\n  // Path initialization\n  this.complex = type.ComplexPath(path);\n  this.solvedPath = path;\n\n  if (this.complex)\n    this.solvedPath = helpers.solvePath(this.tree.data, path, this.tree);\n\n  if (this.complex)\n    path.forEach(function(step) {\n      if (type.Object(step) && '$cursor' in step)\n        this._additionnalPaths.push(step.$cursor);\n    }, this);\n\n  // Relevant?\n  this.relevant = this.get(false) !== undefined;\n\n  // Root listeners\n  function update(previousData) {\n    var record = helpers.getIn(previousData, self.solvedPath, self.tree);\n\n    if (self.recording && !self.undoing) {\n\n      // Handle archive\n      self.archive.add(record);\n    }\n\n    self.undoing = false;\n    return self.emit('update', {\n      data: self.get(false),\n      previousData: record\n    });\n  }\n\n  this.updateHandler = function(e) {\n    var log = e.data.log,\n        previousData = e.data.previousData,\n        shouldFire = false,\n        c, p, l, m, i, j;\n\n    // Solving path if needed\n    if (self.complex)\n      self.solvedPath = helpers.solvePath(self.tree.data, self.path, self.tree);\n\n    // If selector listens at tree, we fire\n    if (!self.path.length)\n      return update(previousData);\n\n    // Checking update log to see whether the cursor should update.\n    if (self.solvedPath)\n      shouldFire = helpers.solveUpdate(\n        log,\n        [self.solvedPath].concat(self._additionnalPaths)\n      );\n\n    // Handling relevancy\n    var data = self.get(false) !== undefined;\n\n    if (self.relevant) {\n      if (data && shouldFire) {\n        update(previousData);\n      }\n      else if (!data) {\n        self.emit('irrelevant');\n        self.relevant = false;\n      }\n    }\n    else {\n      if (data && shouldFire) {\n        self.emit('relevant');\n        update(previousData);\n        self.relevant = true;\n      }\n    }\n  };\n\n  // Lazy binding\n  var bound = false;\n\n  this._lazyBind = function() {\n    if (bound)\n      return;\n    bound = true;\n\n    self.tree.on('update', self.updateHandler);\n  };\n\n  this.on = helpers.before(this._lazyBind, this.on.bind(this));\n  this.once = helpers.before(this._lazyBind, this.once.bind(this));\n\n  if (this.complex)\n    this._lazyBind();\n}\n\nhelpers.inherits(Cursor, EventEmitter);\n\n/**\n * Predicates\n */\nCursor.prototype.isRoot = function() {\n  return !this.path.length;\n};\n\nCursor.prototype.isLeaf = function() {\n  return type.Primitive(this.get(false));\n};\n\nCursor.prototype.isBranch = function() {\n  return !this.isLeaf() && !this.isRoot();\n};\n\n/**\n * Traversal\n */\nCursor.prototype.root = function() {\n  return this.tree.root;\n};\n\nCursor.prototype.select = function(path) {\n  if (arguments.length > 1)\n    path = helpers.arrayOf(arguments);\n\n  if (!type.Path(path))\n    throw Error('baobab.Cursor.select: invalid path.');\n  return this.tree.select(this.path.concat(path));\n};\n\nCursor.prototype.up = function() {\n  if (this.solvedPath && this.solvedPath.length)\n    return this.tree.select(this.path.slice(0, -1));\n  else\n    return null;\n};\n\nCursor.prototype.left = function() {\n  var last = +this.solvedPath[this.solvedPath.length - 1];\n\n  if (isNaN(last))\n    throw Error('baobab.Cursor.left: cannot go left on a non-list type.');\n\n  return last ?\n    this.tree.select(this.solvedPath.slice(0, -1).concat(last - 1)) :\n    null;\n};\n\nCursor.prototype.leftmost = function() {\n  var last = +this.solvedPath[this.solvedPath.length - 1];\n\n  if (isNaN(last))\n    throw Error('baobab.Cursor.leftmost: cannot go left on a non-list type.');\n\n  return this.tree.select(this.solvedPath.slice(0, -1).concat(0));\n};\n\nCursor.prototype.right = function() {\n  var last = +this.solvedPath[this.solvedPath.length - 1];\n\n  if (isNaN(last))\n    throw Error('baobab.Cursor.right: cannot go right on a non-list type.');\n\n  if (last + 1 === this.up().get(false).length)\n    return null;\n\n  return this.tree.select(this.solvedPath.slice(0, -1).concat(last + 1));\n};\n\nCursor.prototype.rightmost = function() {\n  var last = +this.solvedPath[this.solvedPath.length - 1];\n\n  if (isNaN(last))\n    throw Error('baobab.Cursor.right: cannot go right on a non-list type.');\n\n  var list = this.up().get(false);\n\n  return this.tree.select(this.solvedPath.slice(0, -1).concat(list.length - 1));\n};\n\nCursor.prototype.down = function() {\n  var last = +this.solvedPath[this.solvedPath.length - 1];\n\n  if (!(this.get(false) instanceof Array))\n    return null;\n\n  return this.tree.select(this.solvedPath.concat(0));\n};\n\nCursor.prototype.map = function(fn, scope) {\n  var array = this.get(false),\n      l = arguments.length;\n\n  if (!type.Array(array))\n    throw Error('baobab.Cursor.map: cannot map a non-list type.');\n\n  return array.map(function(item, i) {\n    return fn.call(\n      l > 1 ? scope : this,\n      this.select(i),\n      i\n    );\n  }, this);\n};\n\n/**\n * Access\n */\nCursor.prototype.get = function(path) {\n\n  if (!this.solvedPath)\n    return;\n\n  var skipEvent = false;\n\n  if (path === false) {\n    path = [];\n    skipEvent = true;\n  }\n\n  if (arguments.length > 1)\n    path = helpers.arrayOf(arguments);\n\n  var fullPath = this.solvedPath.concat(\n    [].concat(path || path === 0 ? path : [])\n  );\n\n  // Retrieving data\n  var data = helpers.getIn(this.tree.data, fullPath, this.tree);\n\n  // Emitting an event\n  if (!skipEvent)\n    this.tree.emit('get', {path: fullPath, data: data});\n\n  return data;\n};\n\n/**\n * Update\n */\nfunction pathPolymorphism(method, allowedType, key, val) {\n  if (arguments.length > 5)\n    throw Error('baobab.Cursor.' + method + ': too many arguments.');\n\n  if (method === 'unset') {\n    val = true;\n\n    if (arguments.length === 2)\n      key = [];\n  }\n\n  else if (arguments.length < 4) {\n    val = key;\n    key = [];\n  }\n\n  if (!type.Path(key))\n    throw Error('baobab.Cursor.' + method + ': invalid path \"' + key + '\".');\n\n  // Splice exception\n  if (method === 'splice' &&\n      !type.Splicer(val)) {\n    if (type.Array(val))\n      val = [val];\n    else\n      throw Error('baobab.Cursor.splice: incorrect value.');\n  }\n\n  // Checking value validity\n  if (allowedType && !allowedType(val))\n    throw Error('baobab.Cursor.' + method + ': incorrect value.');\n\n  var path = [].concat(key),\n      solvedPath = helpers.solvePath(this.get(false), path, this.tree);\n\n  if (!solvedPath)\n    throw Error('baobab.Cursor.' + method + ': could not solve dynamic path.');\n\n  var leaf = {};\n  leaf['$' + method] = val;\n\n  var spec = helpers.pathObject(solvedPath, leaf);\n\n  return spec;\n}\n\nfunction makeUpdateMethod(command, type) {\n  Cursor.prototype[command] = function() {\n    var spec = pathPolymorphism.bind(this, command, type).apply(this, arguments);\n\n    return this.update(spec, true);\n  };\n}\n\nmakeUpdateMethod('set');\nmakeUpdateMethod('apply', type.Function);\nmakeUpdateMethod('chain', type.Function);\nmakeUpdateMethod('push');\nmakeUpdateMethod('unshift');\nmakeUpdateMethod('merge', type.Object);\nmakeUpdateMethod('splice');\n\nCursor.prototype.unset = function(key) {\n  if (key === undefined && this.isRoot())\n    throw Error('baobab.Cursor.unset: cannot remove root node.');\n\n  var spec = pathPolymorphism.bind(this, 'unset', null).apply(this, arguments);\n\n  return this.update(spec, true);\n};\n\nCursor.prototype.update = function(spec, skipMerge) {\n  if (!type.Object(spec))\n    throw Error('baobab.Cursor.update: invalid specifications.');\n\n  if (!this.solvedPath)\n    throw Error('baobab.Cursor.update: could not solve the cursor\\'s dynamic path.');\n\n  this.tree.stack(helpers.pathObject(this.solvedPath, spec), skipMerge);\n  return this;\n};\n\n/**\n * History\n */\nCursor.prototype.startRecording = function(maxRecords) {\n  maxRecords = maxRecords || 5;\n\n  if (maxRecords < 1)\n    throw Error('baobab.Cursor.startRecording: invalid maximum number of records.');\n\n  if (this.archive)\n    return this;\n\n  // Lazy bind\n  this._lazyBind();\n\n  this.archive = helpers.archive(maxRecords);\n  this.recording = true;\n  return this;\n};\n\nCursor.prototype.stopRecording = function() {\n  this.recording = false;\n  return this;\n};\n\nCursor.prototype.undo = function(steps) {\n  steps = steps || 1;\n\n  if (!this.recording)\n    throw Error('baobab.Cursor.undo: cursor is not recording.');\n\n  if (!type.PositiveInteger(steps))\n    throw Error('baobab.Cursor.undo: expecting a positive integer.');\n\n  var record = this.archive.back(steps);\n\n  if (!record)\n    throw Error('baobab.Cursor.undo: cannot find a relevant record (' + steps + ' back).');\n\n  this.undoing = true;\n  return this.set(record);\n};\n\nCursor.prototype.hasHistory = function() {\n  return !!(this.archive && this.archive.get().length);\n};\n\nCursor.prototype.getHistory = function() {\n  return this.archive ? this.archive.get() : [];\n};\n\nCursor.prototype.clearHistory = function() {\n  this.archive = null;\n  return this;\n};\n\n/**\n * Releasing\n */\nCursor.prototype.release = function() {\n\n  // Removing listener on parent\n  this.tree.off('update', this.updateHandler);\n\n  // If the cursor is hashed, we unsubscribe from the parent\n  if (this.hash)\n    delete this.tree._cursors[this.hash];\n\n  // Dereferencing\n  delete this.tree;\n  delete this.path;\n  delete this.solvedPath;\n  delete this.archive;\n\n  // Killing emitter\n  this.kill();\n};\n\n/**\n * Output\n */\nCursor.prototype.toJSON = function() {\n  return this.get();\n};\n\nCursor.prototype.toString = function() {\n  return this._identity;\n};\n\n/**\n * Export\n */\nmodule.exports = Cursor;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/src/cursor.js\n ** module id = 237\n ** module chunks = 1 3\n **/","(function() {\n  'use strict';\n\n  /**\n   * Here is the list of every allowed parameter when using Emitter#on:\n   * @type {Object}\n   */\n  var __allowedOptions = {\n    once: 'boolean',\n    scope: 'object'\n  };\n\n  /**\n   * Incremental id used to order event handlers.\n   */\n  var __order = 0;\n\n  /**\n   * A simple helper to shallowly merge two objects. The second one will \"win\"\n   * over the first one.\n   *\n   * @param  {object}  o1 First target object.\n   * @param  {object}  o2 Second target object.\n   * @return {object}     Returns the merged object.\n   */\n  function shallowMerge(o1, o2) {\n    var o = {},\n        k;\n\n    for (k in o1) o[k] = o1[k];\n    for (k in o2) o[k] = o2[k];\n\n    return o;\n  }\n\n  /**\n   * Is the given variable a plain JavaScript object?\n   *\n   * @param  {mixed}  v   Target.\n   * @return {boolean}    The boolean result.\n   */\n  function isPlainObject(v) {\n    return v &&\n           typeof v === 'object' &&\n           !Array.isArray(v) &&\n           !(v instanceof Function) &&\n           !(v instanceof RegExp);\n  }\n\n  /**\n   * Iterate over an object that may have ES6 Symbols.\n   *\n   * @param  {object}   object  Object on which to iterate.\n   * @param  {function} fn      Iterator function.\n   * @param  {object}   [scope] Optional scope.\n   */\n  function forIn(object, fn, scope) {\n    var symbols,\n        k,\n        i,\n        l;\n\n    for (k in object)\n      fn.call(scope || null, k, object[k]);\n\n    if (Object.getOwnPropertySymbols) {\n      symbols = Object.getOwnPropertySymbols(object);\n\n      for (i = 0, l = symbols.length; i < l; i++)\n        fn.call(scope || null, symbols[i], object[symbols[i]]);\n    }\n  }\n\n  /**\n   * The emitter's constructor. It initializes the handlers-per-events store and\n   * the global handlers store.\n   *\n   * Emitters are useful for non-DOM events communication. Read its methods\n   * documentation for more information about how it works.\n   *\n   * @return {Emitter}         The fresh new instance.\n   */\n  var Emitter = function() {\n    this._enabled = true;\n\n    // Dirty trick that will set the necessary properties to the emitter\n    this.unbindAll();\n  };\n\n  /**\n   * This method unbinds every handlers attached to every or any events. So,\n   * these functions will no more be executed when the related events are\n   * emitted. If the functions were not bound to the events, nothing will\n   * happen, and no error will be thrown.\n   *\n   * Usage:\n   * ******\n   * > myEmitter.unbindAll();\n   *\n   * @return {Emitter}      Returns this.\n   */\n  Emitter.prototype.unbindAll = function() {\n\n    this._handlers = {};\n    this._handlersAll = [];\n    this._handlersComplex = [];\n\n    return this;\n  };\n\n\n  /**\n   * This method binds one or more functions to the emitter, handled to one or a\n   * suite of events. So, these functions will be executed anytime one related\n   * event is emitted.\n   *\n   * It is also possible to bind a function to any emitted event by not\n   * specifying any event to bind the function to.\n   *\n   * Recognized options:\n   * *******************\n   *  - {?boolean} once   If true, the handlers will be unbound after the first\n   *                      execution. Default value: false.\n   *  - {?object}  scope  If a scope is given, then the listeners will be called\n   *                      with this scope as \"this\".\n   *\n   * Variant 1:\n   * **********\n   * > myEmitter.on('myEvent', function(e) { console.log(e); });\n   * > // Or:\n   * > myEmitter.on('myEvent', function(e) { console.log(e); }, { once: true });\n   *\n   * @param  {string}   event   The event to listen to.\n   * @param  {function} handler The function to bind.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 2:\n   * **********\n   * > myEmitter.on(\n   * >   ['myEvent1', 'myEvent2'],\n   * >   function(e) { console.log(e); }\n   * >);\n   * > // Or:\n   * > myEmitter.on(\n   * >   ['myEvent1', 'myEvent2'],\n   * >   function(e) { console.log(e); }\n   * >   { once: true }}\n   * >);\n   *\n   * @param  {array}    events  The events to listen to.\n   * @param  {function} handler The function to bind.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 3:\n   * **********\n   * > myEmitter.on({\n   * >   myEvent1: function(e) { console.log(e); },\n   * >   myEvent2: function(e) { console.log(e); }\n   * > });\n   * > // Or:\n   * > myEmitter.on({\n   * >   myEvent1: function(e) { console.log(e); },\n   * >   myEvent2: function(e) { console.log(e); }\n   * > }, { once: true });\n   *\n   * @param  {object}  bindings An object containing pairs event / function.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 4:\n   * **********\n   * > myEmitter.on(function(e) { console.log(e); });\n   * > // Or:\n   * > myEmitter.on(function(e) { console.log(e); }, { once: true});\n   *\n   * @param  {function} handler The function to bind to every events.\n   * @param  {?object}  options Eventually some options.\n   * @return {Emitter}          Returns this.\n   */\n  Emitter.prototype.on = function(a, b, c) {\n    var i,\n        l,\n        k,\n        event,\n        eArray,\n        handlersList,\n        bindingObject;\n\n    // Variant 3\n    if (isPlainObject(a)) {\n      forIn(a, function(name, fn) {\n        this.on(name, fn, b);\n      }, this);\n\n      return this;\n    }\n\n    // Variant 1, 2 and 4\n    if (typeof a === 'function') {\n      c = b;\n      b = a;\n      a = null;\n    }\n\n    eArray = [].concat(a);\n\n    for (i = 0, l = eArray.length; i < l; i++) {\n      event = eArray[i];\n\n      bindingObject = {\n        order: __order++,\n        fn: b\n      };\n\n      // Defining the list in which the handler should be inserted\n      if (typeof event === 'string' || typeof event === 'symbol') {\n        if (!this._handlers[event])\n          this._handlers[event] = [];\n        handlersList = this._handlers[event];\n        bindingObject.type = event;\n      }\n      else if (event instanceof RegExp) {\n        handlersList = this._handlersComplex;\n        bindingObject.pattern = event;\n      }\n      else if (event === null) {\n        handlersList = this._handlersAll;\n      }\n      else {\n        throw Error('Emitter.on: invalid event.');\n      }\n\n      // Appending needed properties\n      for (k in c || {})\n        if (__allowedOptions[k])\n          bindingObject[k] = c[k];\n\n      handlersList.push(bindingObject);\n    }\n\n    return this;\n  };\n\n\n  /**\n   * This method works exactly as the previous #on, but will add an options\n   * object if none is given, and set the option \"once\" to true.\n   *\n   * The polymorphism works exactly as with the #on method.\n   */\n  Emitter.prototype.once = function() {\n    var args = Array.prototype.slice.call(arguments),\n        li = args.length - 1;\n\n    if (isPlainObject(args[li]) && args.length > 1)\n      args[li] = shallowMerge(args[li], {once: true});\n    else\n      args.push({once: true});\n\n    return this.on.apply(this, args);\n  };\n\n\n  /**\n   * This method unbinds one or more functions from events of the emitter. So,\n   * these functions will no more be executed when the related events are\n   * emitted. If the functions were not bound to the events, nothing will\n   * happen, and no error will be thrown.\n   *\n   * Variant 1:\n   * **********\n   * > myEmitter.off('myEvent', myHandler);\n   *\n   * @param  {string}   event   The event to unbind the handler from.\n   * @param  {function} handler The function to unbind.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 2:\n   * **********\n   * > myEmitter.off(['myEvent1', 'myEvent2'], myHandler);\n   *\n   * @param  {array}    events  The events to unbind the handler from.\n   * @param  {function} handler The function to unbind.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 3:\n   * **********\n   * > myEmitter.off({\n   * >   myEvent1: myHandler1,\n   * >   myEvent2: myHandler2\n   * > });\n   *\n   * @param  {object} bindings An object containing pairs event / function.\n   * @return {Emitter}         Returns this.\n   *\n   * Variant 4:\n   * **********\n   * > myEmitter.off(myHandler);\n   *\n   * @param  {function} handler The function to unbind from every events.\n   * @return {Emitter}          Returns this.\n   *\n   * Variant 5:\n   * **********\n   * > myEmitter.off(event);\n   *\n   * @param  {string} event     The event we should unbind.\n   * @return {Emitter}          Returns this.\n   */\n  function filter(target, fn) {\n    target = target || [];\n\n    var a = [],\n        l,\n        i;\n\n    for (i = 0, l = target.length; i < l; i++)\n      if (target[i].fn !== fn)\n        a.push(target[i]);\n\n    return a;\n  }\n\n  Emitter.prototype.off = function(events, fn) {\n    var i,\n        n,\n        k,\n        event;\n\n    // Variant 4:\n    if (arguments.length === 1 && typeof events === 'function') {\n      fn = arguments[0];\n\n      // Handlers bound to events:\n      for (k in this._handlers) {\n        this._handlers[k] = filter(this._handlers[k], fn);\n\n        if (this._handlers[k].length === 0)\n          delete this._handlers[k];\n      }\n\n      // Generic Handlers\n      this._handlersAll = filter(this._handlersAll, fn);\n\n      // Complex handlers\n      this._handlersComplex = filter(this._handlersComplex, fn);\n    }\n\n    // Variant 5\n    else if (arguments.length === 1 &&\n             (typeof events === 'string' || typeof events === 'symbol')) {\n      delete this._handlers[events];\n    }\n\n    // Variant 1 and 2:\n    else if (arguments.length === 2) {\n      var eArray = [].concat(events);\n\n      for (i = 0, n = eArray.length; i < n; i++) {\n        event = eArray[i];\n\n        this._handlers[event] = filter(this._handlers[event], fn);\n\n        if ((this._handlers[event] || []).length === 0)\n          delete this._handlers[event];\n      }\n    }\n\n    // Variant 3\n    else if (isPlainObject(events)) {\n      forIn(events, this.off, this);\n    }\n\n    return this;\n  };\n\n  /**\n   * This method retrieve the listeners attached to a particular event.\n   *\n   * @param  {?string}    Name of the event.\n   * @return {array}      Array of handler functions.\n   */\n  Emitter.prototype.listeners = function(event) {\n    var handlers = this._handlersAll || [],\n        complex = false,\n        h,\n        i,\n        l;\n\n    if (!event)\n      throw Error('Emitter.listeners: no event provided.');\n\n    handlers = handlers.concat(this._handlers[event] || []);\n\n    for (i = 0, l = this._handlersComplex.length; i < l; i++) {\n      h = this._handlersComplex[i];\n\n      if (~event.search(h.pattern)) {\n        complex = true;\n        handlers.push(h);\n      }\n    }\n\n    // If we have any complex handlers, we need to sort\n    if (this._handlersAll.length || complex)\n      return handlers.sort(function(a, b) {\n        return a.order - b.order;\n      });\n    else\n      return handlers.slice(0);\n  };\n\n  /**\n   * This method emits the specified event(s), and executes every handlers bound\n   * to the event(s).\n   *\n   * Use cases:\n   * **********\n   * > myEmitter.emit('myEvent');\n   * > myEmitter.emit('myEvent', myData);\n   * > myEmitter.emit(['myEvent1', 'myEvent2']);\n   * > myEmitter.emit(['myEvent1', 'myEvent2'], myData);\n   * > myEmitter.emit({myEvent1: myData1, myEvent2: myData2});\n   *\n   * @param  {string|array} events The event(s) to emit.\n   * @param  {object?}      data   The data.\n   * @return {Emitter}             Returns this.\n   */\n  Emitter.prototype.emit = function(events, data) {\n\n    // Short exit if the emitter is disabled\n    if (!this._enabled)\n      return this;\n\n    // Object variant\n    if (isPlainObject(events)) {\n      forIn(events, this.emit, this);\n      return this;\n    }\n\n    var eArray = [].concat(events),\n        onces = [],\n        event,\n        parent,\n        handlers,\n        handler,\n        i,\n        j,\n        l,\n        m;\n\n    for (i = 0, l = eArray.length; i < l; i++) {\n      handlers = this.listeners(eArray[i]);\n\n      for (j = 0, m = handlers.length; j < m; j++) {\n        handler = handlers[j];\n        event = {\n          type: eArray[i],\n          target: this\n        };\n\n        if (arguments.length > 1)\n          event.data = data;\n\n        handler.fn.call('scope' in handler ? handler.scope : this, event);\n\n        if (handler.once)\n          onces.push(handler);\n      }\n\n      // Cleaning onces\n      for (j = onces.length - 1; j >= 0; j--) {\n        parent = onces[j].type ?\n          this._handlers[onces[j].type] :\n          onces[j].pattern ?\n            this._handlersComplex :\n            this._handlersAll;\n\n        parent.splice(parent.indexOf(onces[j]), 1);\n      }\n    }\n\n    return this;\n  };\n\n\n  /**\n   * This method will unbind all listeners and make it impossible to ever\n   * rebind any listener to any event.\n   */\n  Emitter.prototype.kill = function() {\n\n    this.unbindAll();\n    this._handlers = null;\n    this._handlersAll = null;\n    this._handlersComplex = null;\n    this._enabled = false;\n\n    // Nooping methods\n    this.unbindAll =\n    this.on =\n    this.once =\n    this.off =\n    this.emit =\n    this.listeners = Function.prototype;\n  };\n\n\n  /**\n   * This method disabled the emitter, which means its emit method will do\n   * nothing.\n   *\n   * @return {Emitter} Returns this.\n   */\n  Emitter.prototype.disable = function() {\n    this._enabled = false;\n\n    return this;\n  };\n\n\n  /**\n   * This method enables the emitter.\n   *\n   * @return {Emitter} Returns this.\n   */\n  Emitter.prototype.enable = function() {\n    this._enabled = true;\n\n    return this;\n  };\n\n\n  /**\n   * Version:\n   */\n  Emitter.version = '3.1.1';\n\n\n  // Export:\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      exports = module.exports = Emitter;\n    exports.Emitter = Emitter;\n  } else if (typeof define === 'function' && define.amd)\n    define('emmett', [], function() {\n      return Emitter;\n    });\n  else\n    this.Emitter = Emitter;\n}).call(this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/~/emmett/emmett.js\n ** module id = 238\n ** module chunks = 1 3\n **/","/**\n * Baobab Helpers\n * ===============\n *\n * Miscellaneous helper functions.\n */\nvar type = require('./type.js');\n\n// Make a real array of an array-like object\nfunction arrayOf(o) {\n  return Array.prototype.slice.call(o);\n}\n\n// Decorate a function by applying something before it\nfunction before(decorator, fn) {\n  return function() {\n    decorator.apply(null, arguments);\n    fn.apply(null, arguments);\n  };\n}\n\n// Non-mutative splice function\nfunction splice(array, index, nb /*, &elements */) {\n  var elements = arrayOf(arguments).slice(3);\n\n  return array\n    .slice(0, index)\n    .concat(elements)\n    .concat(array.slice(index + nb));\n}\n\n// Shallow merge\nfunction shallowMerge(o1, o2) {\n  var o = {},\n      k;\n\n  for (k in o1) o[k] = o1[k];\n  for (k in o2) o[k] = o2[k];\n\n  return o;\n}\n\n// Clone a regexp\nfunction cloneRegexp(re) {\n  var pattern = re.source,\n      flags = '';\n\n  if (re.global) flags += 'g';\n  if (re.multiline) flags += 'm';\n  if (re.ignoreCase) flags += 'i';\n  if (re.sticky) flags += 'y';\n  if (re.unicode) flags += 'u';\n\n  return new RegExp(pattern, flags);\n}\n\n// Cloning function\nfunction cloner(deep, item) {\n  if (!item ||\n      typeof item !== 'object' ||\n      item instanceof Error ||\n      ('ArrayBuffer' in global && item instanceof ArrayBuffer))\n    return item;\n\n  // Array\n  if (type.Array(item)) {\n    if (deep) {\n      var i, l, a = [];\n      for (i = 0, l = item.length; i < l; i++)\n        a.push(deepClone(item[i]));\n      return a;\n    }\n    else {\n      return item.slice(0);\n    }\n  }\n\n  // Date\n  if (type.Date(item))\n    return new Date(item.getTime());\n\n  // RegExp\n  if (item instanceof RegExp)\n    return cloneRegexp(item);\n\n  // Object\n  if (type.Object(item)) {\n    var k, o = {};\n\n    if (item.constructor && item.constructor !== Object)\n      o = Object.create(item.constructor.prototype);\n\n    for (k in item)\n      if (item.hasOwnProperty(k))\n        o[k] = deep ? deepClone(item[k]) : item[k];\n    return o;\n  }\n\n  return item;\n}\n\n// Shallow & deep cloning functions\nvar shallowClone = cloner.bind(null, false),\n    deepClone = cloner.bind(null, true);\n\n// Freezing function\nfunction freezer(deep, o) {\n  if (typeof o !== 'object')\n    return;\n\n  Object.freeze(o);\n\n  if (!deep)\n    return;\n\n  if (Array.isArray(o)) {\n\n    // Iterating through the elements\n    var i,\n        l;\n\n    for (i = 0, l = o.length; i < l; i++)\n      deepFreeze(o[i]);\n  }\n  else {\n    var p,\n        k;\n\n    for (k in o) {\n      p = o[k];\n\n      if (!p ||\n          !o.hasOwnProperty(k) ||\n          typeof p !== 'object' ||\n          Object.isFrozen(p))\n        continue;\n\n      deepFreeze(p);\n    }\n  }\n}\n\n// Shallow & deep freezing function\nvar freeze = Object.freeze ? freezer.bind(null, false) : Function.prototype,\n    deepFreeze = Object.freeze ? freezer.bind(null, true) : Function.prototype;\n\n// Simplistic composition\nfunction compose(fn1, fn2) {\n  return function(arg) {\n    return fn2(fn1(arg));\n  };\n}\n\n// Get first item matching predicate in list\nfunction first(a, fn) {\n  var i, l;\n  for (i = 0, l = a.length; i < l; i++) {\n    if (fn(a[i]))\n      return a[i];\n  }\n  return;\n}\n\nfunction index(a, fn) {\n  var i, l;\n  for (i = 0, l = a.length; i < l; i++) {\n    if (fn(a[i]))\n      return i;\n  }\n  return -1;\n}\n\n// Compare object to spec\nfunction compare(object, spec) {\n  var ok = true,\n      k;\n\n  // If we reached here via a recursive call, object may be undefined because\n  // not all items in a collection will have the same deep nesting structure\n  if (!object) {\n    return false;\n  }\n\n  for (k in spec) {\n    if (type.Object(spec[k])) {\n      ok = ok && compare(object[k], spec[k]);\n    }\n    else if (type.Array(spec[k])) {\n      ok = ok && !!~spec[k].indexOf(object[k]);\n    }\n    else {\n      if (object[k] !== spec[k])\n        return false;\n    }\n  }\n\n  return ok;\n}\n\nfunction firstByComparison(object, spec) {\n  return first(object, function(e) {\n    return compare(e, spec);\n  });\n}\n\nfunction indexByComparison(object, spec) {\n  return index(object, function(e) {\n    return compare(e, spec);\n  });\n}\n\n// Retrieve nested objects\nfunction getIn(object, path, tree) {\n  path = path || [];\n\n  var c = object,\n      p,\n      i,\n      l;\n\n  for (i = 0, l = path.length; i < l; i++) {\n    if (!c)\n      return;\n\n    if (typeof path[i] === 'function') {\n      if (!type.Array(c))\n        return;\n\n      c = first(c, path[i]);\n    }\n    else if (typeof path[i] === 'object') {\n      if (tree && '$cursor' in path[i]) {\n        if (!type.Path(path[i].$cursor))\n          throw Error('baobab.getIn: $cursor path must be an array.');\n\n        p = tree.get(path[i].$cursor);\n        c = c[p];\n      }\n\n      else if (!type.Array(c)) {\n        return;\n      }\n\n      else {\n        c = firstByComparison(c, path[i]);\n      }\n    }\n    else {\n      c = c[path[i]];\n    }\n  }\n\n  return c;\n}\n\n// Solve a complex path\nfunction solvePath(object, path, tree) {\n  var solvedPath = [],\n      c = object,\n      idx,\n      i,\n      l;\n\n  for (i = 0, l = path.length; i < l; i++) {\n    if (!c)\n      return null;\n\n    if (typeof path[i] === 'function') {\n      if (!type.Array(c))\n        return;\n\n      idx = index(c, path[i]);\n      solvedPath.push(idx);\n      c = c[idx];\n    }\n    else if (typeof path[i] === 'object') {\n      if (tree && '$cursor' in path[i]) {\n        if (!type.Path(path[i].$cursor))\n          throw Error('baobab.getIn: $cursor path must be an array.');\n\n        p = tree.get(path[i].$cursor);\n        solvedPath.push(p);\n        c = c[p];\n      }\n\n      else if (!type.Array(c)) {\n        return;\n      }\n\n      else {\n        idx = indexByComparison(c, path[i]);\n        solvedPath.push(idx);\n        c = c[idx];\n      }\n    }\n    else {\n      solvedPath.push(path[i]);\n      c = c[path[i]] || {};\n    }\n  }\n\n  return solvedPath;\n}\n\n// Determine whether an update should fire for the given paths\n// NOTES: 1) if performance becomes an issue, the threefold loop can be\n//           simplified to become a complex twofold one.\n//        2) a regex version could also work but I am not confident it would be\n//           faster.\nfunction solveUpdate(log, paths) {\n  var i, j, k, l, m, n, p, c, s;\n\n  // Looping through possible paths\n  for (i = 0, l = paths.length; i < l; i++) {\n    p = paths[i];\n\n    if (!p.length)\n      return true;\n\n    // Looping through logged paths\n    for (j = 0, m = log.length; j < m; j++) {\n      c = log[j];\n\n      if (!c.length)\n        return true;\n\n      // Looping through steps\n      for (k = 0, n = c.length; k < n; k++) {\n        s = c[k];\n\n        // If path is not relevant, we break\n        if (s != p[k])\n          break;\n\n        // If we reached last item and we are relevant\n        if (k + 1 === n || k + 1 === p.length)\n          return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n// Return a fake object relative to the given path\nfunction pathObject(path, spec) {\n  var l = path.length,\n      o = {},\n      c = o,\n      i;\n\n  if (!l)\n    o = spec;\n\n  for (i = 0; i < l; i++) {\n    c[path[i]] = (i + 1 === l) ? spec : {};\n    c = c[path[i]];\n  }\n\n  return o;\n}\n\n// Shim used for cross-compatible event emitting extension\nfunction inherits(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  var TempCtor = function () {};\n  TempCtor.prototype = superCtor.prototype;\n  ctor.prototype = new TempCtor();\n  ctor.prototype.constructor = ctor;\n}\n\n// Archive\nfunction archive(size) {\n  var records = [];\n\n  return {\n    add: function(record) {\n      records.unshift(record);\n\n      if (records.length > size)\n        records.length = size;\n    },\n    back: function(steps) {\n      var record = records[steps - 1];\n\n      if (record)\n        records = records.slice(steps);\n      return record;\n    },\n    get: function() {\n      return records;\n    }\n  };\n}\n\nmodule.exports = {\n  archive: archive,\n  arrayOf: arrayOf,\n  before: before,\n  freeze: freeze,\n  deepClone: deepClone,\n  deepFreeze: deepFreeze,\n  shallowClone: shallowClone,\n  shallowMerge: shallowMerge,\n  compose: compose,\n  getIn: getIn,\n  inherits: inherits,\n  pathObject: pathObject,\n  solvePath: solvePath,\n  solveUpdate: solveUpdate,\n  splice: splice\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/src/helpers.js\n ** module id = 239\n ** module chunks = 1 3\n **/","/**\n * Baobab Type Checking\n * =====================\n *\n * Misc helpers functions used throughout the library to perform some type\n * tests at runtime.\n *\n * @christianalfoni\n */\nvar type = {};\n\n/**\n * Helpers\n */\nfunction anyOf(value, allowed) {\n  return allowed.some(function(t) {\n    return type[t](value);\n  });\n}\n\n/**\n * Simple types\n */\ntype.Array = function(value) {\n  return Array.isArray(value);\n};\n\ntype.Object = function(value) {\n  return value &&\n         typeof value === 'object' &&\n         !Array.isArray(value) &&\n         !(value instanceof Date) &&\n         !(value instanceof RegExp);\n};\n\ntype.String = function(value) {\n  return typeof value === 'string';\n};\n\ntype.Number = function(value) {\n  return typeof value === 'number';\n};\n\ntype.PositiveInteger = function(value) {\n  return typeof value === 'number' && value > 0 && value % 1 === 0;\n};\n\ntype.Function = function(value) {\n  return typeof value === 'function';\n};\n\ntype.Primitive = function(value) {\n  return value !== Object(value);\n};\n\ntype.Date = function(value) {\n  return value instanceof Date;\n};\n\n/**\n * Complex types\n */\ntype.NonScalar = function(value) {\n  return type.Object(value) || type.Array(value);\n};\n\ntype.Splicer = function(value) {\n  return type.Array(value) &&\n         value.every(type.Array);\n};\n\ntype.Path = function(value, allowed) {\n  allowed = allowed || ['String', 'Number', 'Function', 'Object'];\n\n  if (type.Array(value)) {\n    return value.every(function(step) {\n      return anyOf(step, allowed);\n    });\n  }\n  else {\n    return anyOf(value, allowed);\n  }\n};\n\ntype.ComplexPath = function(value) {\n  return value.some(function(step) {\n    return anyOf(step, ['Object', 'Function']);\n  });\n};\n\ntype.FacetCursors = function(value) {\n  if (!type.Object(value))\n    return false;\n\n  return Object.keys(value).every(function(k) {\n    var v = value[k];\n\n    return type.Path(v, ['String', 'Number', 'Object']) ||\n           v instanceof require('./cursor.js');\n  });\n};\n\ntype.FacetFacets = function(value) {\n  if (!type.Object(value))\n    return false;\n\n  return Object.keys(value).every(function(k) {\n    var v = value[k];\n\n    return typeof v === 'string' ||\n           v instanceof require('./facet.js');\n  });\n};\n\nmodule.exports = type;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/src/type.js\n ** module id = 240\n ** module chunks = 1 3\n **/","/**\n * Baobab Facet Abstraction\n * =========================\n *\n * Facets enable the user to define views on a given Baobab tree.\n */\nvar EventEmitter = require('emmett'),\n    Cursor = require('./cursor.js'),\n    helpers = require('./helpers.js'),\n    type = require('./type.js');\n\nfunction Facet(tree, definition, args) {\n  var self = this;\n\n  var firstTime = true,\n      solved = false,\n      getter = definition.get,\n      facetData = null;\n\n  // Extending event emitter\n  EventEmitter.call(this);\n\n  // Properties\n  this.killed = false;\n  this.tree = tree;\n  this.cursors = {};\n  this.facets = {};\n\n  var cursorsMapping = definition.cursors,\n      facetsMapping = definition.facets,\n      complexCursors = typeof definition.cursors === 'function',\n      complexFacets = typeof definition.facets === 'function';\n\n  // Refreshing the internal mapping\n  function refresh(complexity, targetMapping, targetProperty, mappingType, refreshArgs) {\n    if (!complexity && !firstTime)\n      return;\n\n    solved = false;\n\n    var solvedMapping = targetMapping;\n\n    if (complexity)\n      solvedMapping = targetMapping.apply(this, refreshArgs);\n\n    if (!mappingType(solvedMapping))\n      throw Error('baobab.Facet: incorrect ' + targetProperty + ' mapping.');\n\n    self[targetProperty] = {};\n\n    Object.keys(solvedMapping).forEach(function(k) {\n\n      if (targetProperty === 'cursors') {\n        if (solvedMapping[k] instanceof Cursor) {\n          self.cursors[k] = solvedMapping[k];\n          return;\n        }\n\n        if (type.Path(solvedMapping[k])) {\n          self.cursors[k] = tree.select(solvedMapping[k]);\n          return;\n        }\n      }\n\n      else {\n        if (solvedMapping[k] instanceof Facet) {\n          self.facets[k] = solvedMapping[k];\n          return;\n        }\n\n        if (typeof solvedMapping[k] === 'string') {\n          self.facets[k] = tree.facets[solvedMapping[k]];\n\n          if (!self.facets[k])\n            throw Error('baobab.Facet: unkown \"' + solvedMapping[k] + '\" facet in facets mapping.');\n          return;\n        }\n      }\n    });\n  }\n\n  this.refresh = function(refreshArgs) {\n    refreshArgs = refreshArgs || [];\n\n    if (!type.Array(refreshArgs))\n      throw Error('baobab.Facet.refresh: first argument should be an array.');\n\n    if (cursorsMapping)\n      refresh(\n        complexCursors,\n        cursorsMapping,\n        'cursors',\n        type.FacetCursors,\n        refreshArgs\n      );\n\n    if (facetsMapping)\n      refresh(\n        complexFacets,\n        facetsMapping,\n        'facets',\n        type.FacetFacets,\n        refreshArgs\n      );\n  };\n\n  // Data solving\n  this.get = function() {\n    if (solved)\n      return facetData;\n\n    // Solving\n    var data = {},\n        k;\n\n    for (k in self.facets)\n      data[k] = self.facets[k].get();\n\n    for (k in self.cursors)\n      data[k] = self.cursors[k].get();\n\n    // Applying getter\n    data = typeof getter === 'function' ?\n      getter.call(self, data) :\n      data;\n\n    solved = true;\n    facetData = data;\n\n    return facetData;\n  };\n\n  // Tracking the tree's updates\n  function cursorsPaths(cursors) {\n    return Object.keys(cursors).map(function(k) {\n      return cursors[k].solvedPath;\n    });\n  }\n\n  function facetsPaths(facets) {\n    var paths =  Object.keys(facets).map(function(k) {\n      return cursorsPaths(facets[k].cursors).concat(facetsPaths(facets[k].facets));\n    });\n\n    return [].concat.apply([], paths);\n  }\n\n  this.updateHandler = function(e) {\n    if (self.killed)\n      return;\n\n    var paths = cursorsPaths(self.cursors).concat(facetsPaths(self.facets));\n\n    if (helpers.solveUpdate(e.data.log, paths)) {\n      solved = false;\n      self.emit('update');\n    }\n  };\n\n  // Init routine\n  this.refresh(args);\n  this.tree.on('update', this.updateHandler);\n\n  firstTime = false;\n}\n\nhelpers.inherits(Facet, EventEmitter);\n\nFacet.prototype.release = function() {\n  this.tree.off('update', this.updateHandler);\n\n  this.tree = null;\n  this.cursors = null;\n  this.facets = null;\n  this.killed = true;\n  this.kill();\n};\n\nmodule.exports = Facet;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/src/facet.js\n ** module id = 241\n ** module chunks = 1 3\n **/","/**\n * Baobab Default Options\n * =======================\n *\n */\nmodule.exports = {\n\n  // Should the tree handle its transactions on its own?\n  autoCommit: true,\n\n  // Should the transactions be handled asynchronously?\n  asynchronous: true,\n\n  // Facets registration\n  facets: {},\n\n  // Should the tree's data be immutable?\n  immutable: false,\n\n  // Validation specifications\n  validate: null,\n\n  // Validation behaviour 'rollback' or 'notify'\n  validationBehavior: 'rollback',\n\n  // Should the user be able to write the tree synchronously?\n  syncwrite: false\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/defaults.js\n ** module id = 242\n ** module chunks = 1 3\n **/","/**\n * Baobab Update\n * ==============\n *\n * A handy method to mutate an atom according to the given specification.\n * Mostly inspired by http://facebook.github.io/react/docs/update.html\n */\nvar helpers = require('./helpers.js'),\n    type = require('./type.js');\n\n// Helpers\nfunction makeError(path, message) {\n  var e = new Error('baobab.update: ' + message + ' at path /' +\n                    path.slice(1).join('/'));\n\n  e.path = path;\n  return e;\n}\n\nmodule.exports = function(data, spec, opts) {\n  opts = opts || {};\n\n  var log = {};\n\n  // Shifting root\n  data = {root: helpers.shallowClone(data)};\n\n  // Closure performing the updates themselves\n  var mutator = function(o, spec, path, parent) {\n    path = path || ['root'];\n\n    var hash = path.join('|Î»|'),\n        lastKey = path[path.length - 1],\n        oldValue = o[lastKey],\n        fn,\n        k,\n        v,\n        i,\n        l;\n\n    // Are we at leaf level?\n    var leafLevel = Object.keys(spec).some(function(k) {\n      return k.charAt(0) === '$';\n    });\n\n    // Leaf level updates\n    if (leafLevel) {\n      log[hash] = true;\n\n      for (k in spec) {\n\n        // $unset\n        if (k === '$unset') {\n          var olderKey = path[path.length - 2];\n\n          if (!type.Object(parent[olderKey]))\n            throw makeError(path.slice(0, -1), 'using command $unset on a non-object');\n\n          parent[olderKey] = helpers.shallowClone(o);\n          delete parent[olderKey][lastKey];\n\n          if (opts.immutable)\n            helpers.freeze(parent[olderKey]);\n          break;\n        }\n\n        // $set\n        if (k === '$set') {\n          v = spec.$set;\n\n          o[lastKey] = v;\n        }\n\n        // $apply\n        else if (k === '$apply' || k === '$chain') {\n          fn = spec.$apply || spec.$chain;\n\n          if (typeof fn !== 'function')\n            throw makeError(path, 'using command $apply with a non function');\n\n          o[lastKey] = fn.call(null, oldValue);\n        }\n\n        // $merge\n        else if (k === '$merge') {\n          v = spec.$merge;\n\n          if (!type.Object(o[lastKey]) || !type.Object(v))\n            throw makeError(path, 'using command $merge with a non object');\n\n          o[lastKey] = helpers.shallowMerge(o[lastKey], v);\n        }\n\n        // $splice\n        if (k === '$splice') {\n          v = spec.$splice;\n\n          if (!type.Array(o[lastKey]))\n            throw makeError(path, 'using command $push to a non array');\n\n          for (i = 0, l = v.length; i < l; i++)\n            o[lastKey] = helpers.splice.apply(null, [o[lastKey]].concat(v[i]));\n        }\n\n        // $push\n        if (k === '$push') {\n          v = spec.$push;\n\n          if (!type.Array(o[lastKey]))\n            throw makeError(path, 'using command $push to a non array');\n\n          o[lastKey] = o[lastKey].concat(v);\n        }\n\n        // $unshift\n        if (k === '$unshift') {\n          v = spec.$unshift;\n\n          if (!type.Array(o[lastKey]))\n            throw makeError(path, 'using command $unshift to a non array');\n\n          o[lastKey] = [].concat(v).concat(o[lastKey]);\n        }\n\n        // Deep freezing the new value?\n        if (opts.immutable)\n          helpers.deepFreeze(o);\n      }\n    }\n    else {\n\n      // If nested object does not exist, we create it\n      if (type.Primitive(o[lastKey]))\n        o[lastKey] = {};\n      else\n        o[lastKey] = helpers.shallowClone(o[lastKey]);\n\n      // Should we freeze the parent?\n      if (opts.immutable)\n        helpers.freeze(o);\n\n      for (k in spec)  {\n\n        // Recur\n        mutator(\n          o[lastKey],\n          spec[k],\n          path.concat(k),\n          o\n        );\n      }\n    }\n  };\n\n  mutator(data, spec);\n\n  // Returning data and path log\n  return {\n    data: data.root,\n\n    // SHIFT LOG\n    log: Object.keys(log).map(function(hash) {\n      return hash.split('|Î»|').slice(1);\n    })\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/src/update.js\n ** module id = 243\n ** module chunks = 1 3\n **/","/**\n * Baobab Merge\n * =============\n *\n * A function used to merge updates in the stack.\n */\nvar helpers = require('./helpers.js'),\n    type = require('./type.js');\n\n// Helpers\nvar COMMANDS = ['$unset', '$set', '$apply'];\n\nfunction only(command, commandValue) {\n  var o = {};\n  o[command] = commandValue;\n  return o;\n}\n\n// Main function\nfunction merge(a, b) {\n  var o = helpers.shallowClone(a || {}),\n      leafLevel = false,\n      k,\n      i;\n\n  COMMANDS.forEach(function(c) {\n    if (c in b) {\n      o = only(c, b[c]);\n      leafLevel = true;\n    }\n  });\n\n  if (b.$chain) {\n\n    if (o.$apply)\n      o.$apply = helpers.compose(o.$apply, b.$chain);\n    else\n      o.$apply = b.$chain;\n\n    o = only('$apply', o.$apply);\n    leafLevel = true;\n  }\n\n  if (b.$merge) {\n    o.$merge = helpers.shallowMerge(o.$merge || {}, b.$merge);\n    leafLevel = true;\n  }\n\n  if (b.$splice || b.$splice) {\n    o.$splice = [].concat(o.$splice || []).concat(b.$splice || []);\n    leafLevel = true;\n  }\n\n  if (b.$push || o.$push) {\n    o.$push = [].concat(o.$push || []).concat(b.$push || []);\n    leafLevel = true;\n  }\n\n  if (b.$unshift || o.$unshift) {\n    o.$unshift = [].concat(b.$unshift || []).concat(o.$unshift || []);\n    leafLevel = true;\n  }\n\n  if (leafLevel)\n    return o;\n\n  for (k in o) {\n    if (k.charAt(0) === '$')\n      delete o[k];\n  }\n\n  for (k in b) {\n    if (type.Object(b[k]))\n      o[k] = merge(o[k], b[k]);\n  }\n\n  return o;\n}\n\nmodule.exports = merge;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab/src/merge.js\n ** module id = 244\n ** module chunks = 1 3\n **/","/**\n * Baobab-React Custom Prop Types\n * ===============================\n *\n * PropTypes used to propagate context safely.\n */\n'use strict';\n\nvar type = require('./type.js');\n\nfunction errorMessage(propName, what) {\n  return 'prop type `' + propName + '` is invalid; it must be ' + what + '.';\n}\n\nvar PropTypes = {};\n\nPropTypes.baobab = function (props, propName) {\n  if (!type.Baobab(props[propName])) return new Error(errorMessage(propName, 'a Baobab tree'));\n};\n\nPropTypes.cursors = function (props, propName) {\n  var p = props[propName];\n\n  var valid = type.Object(p) && Object.keys(p).every(function (k) {\n    return type.Cursor(p[k]);\n  });\n\n  if (!valid) return new Error(errorMessage(propName, 'Baobab cursors'));\n};\n\nPropTypes.facets = function (props, propName) {\n  var p = props[propName];\n\n  var valid = type.Object(p) && Object.keys(p).every(function (k) {\n    return type.Facet(p[k]);\n  });\n\n  if (!valid) return new Error(errorMessage(propName, 'Baobab facets'));\n};\n\nmodule.exports = PropTypes;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/baobab-react/dist-modules/utils/prop-types.js\n ** module id = 245\n ** module chunks = 1 3\n **/","import classNames from 'classnames';\nimport {branch} from 'baobab-react/higher-order';\nimport { Link, State, Navigation } from 'react-router';\n\nimport SignInForm from './components/SignInForm'\n\n\nclass Login extends React.Component {\n  constructor(...args) {\n    super(...args);\n    this.state = {};\n  }\n\n  componentWillUpdate(nextProps, nextState) {\n    if (!nextProps || !nextProps.authentication) {\n      return;\n    }\n    const sessionData = nextProps.authentication.sessionData;\n    if (sessionData && !_.get(this.context.router, 'state.isTransitioning')) {\n      const screen = _.get(nextProps, 'authentication.sessionData.user');\n      this.context.router.transitionTo(screen);\n    }\n  }\n\n  render() {\n    var classes = classNames({\n      'container-open': this.props.open\n    });\n\n    return (\n      <Grid>\n        <Row>\n          <Col sm={6}>\n            <PanelContainer>\n              <Panel>\n                \n                <SignInForm /> \n\n              </Panel>\n            </PanelContainer>\n          </Col>\n        </Row>\n      </Grid>\n    );\n  }\n}\n\nLogin.contextTypes = {\n  router: React.PropTypes.object\n};\n\nexport default branch(Login, {\n  cursors: {\n    authentication: 'authentication',\n    awaitingAuthentication: 'awaitingAuthentication'\n  }\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/pages/Login/login.jsx\n **/","/*!\n  Copyright (c) 2015 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = '';\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses += ' ' + arg;\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tclasses += ' ' + classNames.apply(null, arg);\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses += ' ' + key;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.substr(1);\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/classnames/index.js\n ** module id = 251\n ** module chunks = 3\n **/","import {Link, State, Navigation} from 'react-router';\nimport {signIn} from 'actions/authenticationActions';\n\nclass SignInForm extends React.Component {\n  \n  async submitForm(e) {\n    e.preventDefault();\n    await signIn(e);\n  }\n\n  render() {\n    return (\n      <div style={{padding: 25, paddingTop: 0, paddingBottom: 0, margin: 'auto', marginBottom: 25, marginTop: 25}}>                \n        <Form onSubmit={this.submitForm.bind(this)}>\n          <FormGroup>\n            <InputGroup lg>\n              <InputGroupAddon>\n                <Icon glyph='icon-fontello-mail' />\n              </InputGroupAddon>\n              <Input autoFocus type='email' id='emailaddress' className='border-focus-blue' placeholder='support@sketchpixy.com' />\n            </InputGroup>\n          </FormGroup>\n          <FormGroup>\n            <InputGroup lg>\n              <InputGroupAddon>\n                <Icon glyph='icon-fontello-key' />\n              </InputGroupAddon>\n              <Input type='password' id='password' className='border-focus-blue' placeholder='password' />\n            </InputGroup>\n          </FormGroup>\n          <FormGroup>\n            <Grid>\n              <Row>\n                <Col xs={6} collapseLeft collapseRight style={{paddingTop: 10}}>\n                  <Link to='/app/signup'>Create a Rubix account</Link>\n                </Col>\n                <Col xs={6} collapseLeft collapseRight className='text-right'>\n                  <Button outlined lg type='submit' bsStyle='blue' onClick={this.back}>Login</Button>\n                </Col>\n              </Row>\n            </Grid>\n          </FormGroup>\n        </Form>    \n      </div>       \n    );\n  }\n}\n\nexport default SignInForm\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/pages/Login/components/SignInForm.jsx\n **/"],"sourceRoot":""}